#!/usr/bin/env python
# coding: utf-8



import networkx as nx
import csv
import pprint as pp
import pandas as pd
import numpy as np

#####################################################################################################################
# Functions
#####################################################################################################################

def create_graph(directory):
    # Creation of the graphs 
    file_handler = open(directory, "r", encoding = "utf-8")
    reader = csv.reader(file_handler, delimiter = "\t", quotechar = '"', 
                           quoting = csv.QUOTE_NONE)
    reader.__next__()
    edge = []
    for record in reader:
        u = record[0]
        v = record[1]
        edge.append((u, v))
    file_handler.close()
    book = nx.Graph()
    book.add_edges_from(edge)
    return book

def compute_local_community(graph, seed_node_id, alpha, exponent):
    # Creation of the teleporting probability distribution for the selected node
    teleporting_pdistro = {}
    for node_id in graph:
        teleporting_pdistro[node_id] = 0.
    teleporting_pdistro[seed_node_id] = 1.
    # Computation of the PageRank vector
    personal_pageRank = nx.pagerank(graph, alpha = alpha, 
                                    personalization = teleporting_pdistro)
    # Normalize and Sort
    norm_scores = [(node_id, score/(graph.degree[node_id]**exponent)) 
                   for node_id, score in personal_pageRank.items()]
    norm_scores.sort(key = lambda x: (-x[1], x[0]))
    # SWEEP
    index_max_conductance = -1
    min_conductance = float("+inf")
    candidate_community = set()
    candidate_community_complement = set(graph.nodes())
    for sweep_index in range(0, len(norm_scores) - 1):
        # Creation of candidate community and its complement
        current_node = norm_scores[sweep_index][0]
        candidate_community.add(current_node)
        candidate_community_complement.remove(current_node)
        # Evaluation of the quality of the candidate community according to its conductance value
        conductance_value = nx.algorithms.cuts.conductance(graph, 
                                                           candidate_community, 
                                                           candidate_community_complement)
        # Discard local communities with conductance 0 or 1
        if conductance_value == 0. or conductance_value == 1.:
            continue
        # Update the values of variables representing the best solution generated so far
        if conductance_value < min_conductance:
            min_conductance = conductance_value
            index_max_conductance = sweep_index
    # Creation of the set of nodes representing the best local community generated by the sweeping procedure
    min_conductance_set = set([node_id for node_id, normalized_score in 
                               norm_scores[:index_max_conductance + 1]])
    return (min_conductance, min_conductance_set)

def conductance_matrix (idx_node_i, book_j):
    # For each combination of book and character (i.e., node_of_interest), we compute the matrices
    matrix_i_j = pd.DataFrame(data = 0, index = exponent, columns = alpha)
    for a in matrix_i_j.columns:
        matrix_i_j[a] = [compute_local_community(book_j, node_of_interest[idx_node_i], a, exp)[0] 
                         for exp in exponent] 
    return matrix_i_j

def get_adhoc_parameters(matrix):
    # Given the matrices, we can find the parameters corresponding to the minimum conductance
    coordinates_minimum_conductance = np.unravel_index(np.argmin(matrix.values), matrix.shape)
    minimum_conductance = matrix.iloc[coordinates_minimum_conductance]
    parameter_alpha, parameter_exponent = alpha[coordinates_minimum_conductance[1]], exponent[coordinates_minimum_conductance[0]]
    return (parameter_alpha, parameter_exponent, minimum_conductance)

def families(idx_node_i, book_j, alpha, exponent):
    # We compute the composition of the local communities, by character's families
    Baratheon_family = 0
    Lannister_family = 0
    Stark_family = 0
    Targaryen_family = 0
    for node_id in compute_local_community(book_j, node_of_interest[idx_node_i], alpha, exponent)[1]:
        if "baratheon" in node_id.lower().strip():
            Baratheon_family += 1
        elif "lannister" in node_id.lower().strip():
            Lannister_family += 1
        elif "stark" in node_id.lower().strip():
            Stark_family += 1
        elif "targaryen" in node_id.lower().strip():
            Targaryen_family += 1
    return (Baratheon_family, Lannister_family, Stark_family, Targaryen_family, len(compute_local_community(book_j, node_of_interest[idx_node_i], alpha, exponent)[1]))


#####################################################################################################################
# Parameters and inputs
#####################################################################################################################

node_of_interest = ["Daenerys-Targaryen", "Jon-Snow", "Samwell-Tarly", "Tyrion-Lannister"]
directories = ["DMT_2020__HW_2/Part_2/dataset/book_1.tsv", "DMT_2020__HW_2/Part_2/dataset/book_2.tsv", 
              "DMT_2020__HW_2/Part_2/dataset/book_3.tsv", "DMT_2020__HW_2/Part_2/dataset/book_4.tsv"]
# We store all the graph in a single list 
books = [create_graph(directories[i]) for i in range(len(directories))] 
alpha = [0.95, 0.9, 0.85, 0.8, 0.75, 0.7, 0.65, 0.6, 0.55, 0.5, 0.45, 
         0.4, 0.35, 0.3, 0.25, 0.2, 0.15, 0.1, 0.05]
exponent = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]


#####################################################################################################################
# Computations
#####################################################################################################################


# For each combination of book and character (i.e., node_of_interest), we compute the matrices and
# the tuning parameters (alpha and exponent) that give us the minimum conductance

conductance_matrices = []
for book_idx in range(len(books)):
    for node_idx in range(len(node_of_interest)):
        conductance_matrices.append(conductance_matrix(node_idx, books[book_idx]))

alpha = [get_adhoc_parameters(conductance_matrices[i])[0] 
         for i in range(len(conductance_matrices))]
exponent = [get_adhoc_parameters(conductance_matrices[i])[1] 
            for i in range(len(conductance_matrices))]
conductance = [get_adhoc_parameters(conductance_matrices[i])[2] 
               for i in range(len(conductance_matrices))]



# Now that we know which is the best local community, we can analyse its composition

communities = {"Baratheon": [], "Lannister": [], "Stark": [], "Targaryen": [], "members": []}
com_by_row = []
i = 0
for book_idx in range(len(books)):
    for node_idx in range(len(node_of_interest)):
        com_by_row.append(families(node_idx, books[book_idx], alpha[i], exponent[i]))
        i += 1
for val, key in enumerate(communities):
    for i in range(len(com_by_row)):
        communities[key].append(com_by_row[i][val])



# Finally, we store and output all the results
results = pd.DataFrame(data = {"Books": ['Game of Thrones', 'Game of Thrones', 'Game of Thrones', 
                                         'Game of Thrones', 'Clash of Kings', 'Clash of Kings',
                                         'Clash of Kings', 'Clash of Kings', 'Storm of Swords',
                                         'Storm of Swords', 'Storm of Swords', 'Storm of Swords',
                                         'Feast for Crows', 'Feast for Crows', 'Feast for Crows', 
                                         'Feast for Crows'],
                               "Characters": node_of_interest*4, 
                               "Dumping Factor": alpha, "Exponent": exponent, 
                               "Conductance": conductance, "Baratheon": communities["Baratheon"],
                              "Lannister": communities["Lannister"], "Stark": communities["Stark"], 
                              "Targaryen": communities["Targaryen"], "Total # Members": communities["members"]})

results.to_csv("output.tsv", sep='\t', index = False)
